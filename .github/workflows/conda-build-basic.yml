name: ci-code-aster-batch

# bump 1
on:
  workflow_call:
    inputs:
      package_name:
        description: 'package name'
        type: string
        required: true
      boa:
        description: 'use boa'
        type: boolean
        required: true
      debug_build:
        description: 'should produce a debug build'
        type: string
        required: false
        default: "False"
      pkg_dir:
        description: 'work dir'
        type: string
        required: false
        default: src
      work_dir:
        description: 'work dir'
        type: string
        required: false
        default: /home/runner/work
      conda_label:
        description: 'conda label'
        type: string
        required: true
      conda_user:
        description: 'conda user'
        type: string
        required: true
      conda_upstream_label:
        description: 'conda upstream label'
        type: string
        required: false
        default: None
      conda_upstream_user:
        description: 'conda upstream user'
        type: string
        required: false
        default: None
      python_versions:
        description: 'matrix type'
        type: string
        required: false
        default: "3.9,3.10,3.11"
      platforms:
        description: 'matrix type'
        type: string
        required: false
        default: "windows-latest,ubuntu-latest,macos-latest"
      variants:
        description: 'Conda package variant; <variant1_key>=<variant1_value>,<variant2_key>=<variant2_value>'
        type: string
        required: false
      use_quetz:
        description: 'use quetz server'
        type: boolean
        required: false
        default: false

    # Return all outputs so that they can optionally be used in subsequent steps
    outputs:
      conda_label:
        description: "conda label"
        value: ${{ jobs.build_conda.outputs.conda_label }}
      conda_user:
        description: "conda user"
        value: ${{ jobs.build_conda.outputs.conda_user }}

env:
  PKG_DEBUG: "False"
  CONDA_UPSTREAM_LABEL: ${{ inputs.conda_upstream_label }}
  CONDA_UPSTREAM_USER: ${{ inputs.conda_upstream_user }}
  CONDA_DIR: ${{ inputs.pkg_dir }}/${{ inputs.package_name }}
  WORK_DIR: ${{ inputs.work_dir }}
  ARTIFACTS_DIR: ${{ inputs.work_dir }}/artifacts
  CROOT_DIR: ${{ inputs.work_dir }}/build
  CLICOLOR_FORCE: "1"
  VARIANT_STR: ""
  CONDA_CHANNEL: ""

jobs:
  # run a preceding job to get the matrix only if matrix_str is None
  build_matrix:
    uses: ./.github/workflows/matrix-builder.yml
    with:
      python_versions: ${{ inputs.python_versions }}
      platforms: ${{ inputs.platforms }}
      variants: ${{ inputs.variants }}

  build_conda:
    needs: [ build_matrix ]
    name: ${{ inputs.package_name }}-${{ matrix.platform.short }}-${{ matrix.pyver }}-${{ matrix.variants.key }}=${{ matrix.variants.value }}
    runs-on: ${{ matrix.platform.os }}
    defaults:
      run:
        shell: bash -l {0}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.build_matrix.outputs.final_matrix) }}
    outputs:
      conda_label: ${{ inputs.conda_label }}
      conda_user: ${{ inputs.conda_user }}
      package_name: ${{ inputs.package_name }}
    steps:
      - uses: actions/checkout@v3

      - name: Check if conda upstream inputs are not None. If so set equal to output values
        run: |
          if [[ ${{ inputs.conda_upstream_label }} == "None" ]]; then
              echo "CONDA_UPSTREAM_LABEL=${{ inputs.conda_label }}" >> $GITHUB_ENV
          fi
          if [[ ${{ inputs.conda_upstream_user }} == "None" ]]; then
              echo "CONDA_UPSTREAM_USER=${{ inputs.conda_user }}" >> $GITHUB_ENV
          fi

      - name: check if variant_str exists
        if: ${{ inputs.variants }}
        run: |
          echo "VARIANT_STR= --variants \"{'${{ matrix.variants.key }}': '${{ matrix.variants.value }}'}\"" >> $GITHUB_ENV

      - name: Download and extract MacOSX SDK
        if: ${{ runner.os == 'macOS' }}
        run: |
          curl -L https://github.com/phracker/MacOSX-SDKs/releases/download/11.3/MacOSX10.15.sdk.tar.xz | tar -xvJf - -C /Users/runner/work/

      - name: set ENV WORK_DIR
        run: |
          pwd
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            echo "PKG_DIR=win-64" >> $GITHUB_ENV
            echo "WORK_DIR=D:/a/" >> $GITHUB_ENV
            echo "ARTIFACTS_DIR=D:/a/artifacts" >> $GITHUB_ENV
            echo "CROOT_DIR=D:/a/build" >> $GITHUB_ENV
          elif [[ "$RUNNER_OS" == "macOS" ]]; then
            echo "PKG_DIR=osx-64" >> $GITHUB_ENV
            echo "WORK_DIR=/Users/runner/work" >> $GITHUB_ENV
            echo "ARTIFACTS_DIR=/Users/runner/work/artifacts" >> $GITHUB_ENV
            echo "CROOT_DIR=/Users/runner/work/build" >> $GITHUB_ENV
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "PKG_DIR=linux-64" >> $GITHUB_ENV
          fi

      - name: set ENV CONDA_CHANNEL
        run: |
            if [[ ${{ inputs.use_quetz }} == false ]]; then
                echo "CONDA_CHANNEL=${{ env.CONDA_UPSTREAM_USER }}/label/${{ env.CONDA_UPSTREAM_LABEL }}" >> $GITHUB_ENV
            else
                echo "CONDA_CHANNEL=${{ secrets.QUETZ_URL }}/get/${{ env.CONDA_UPSTREAM_LABEL }}" >> $GITHUB_ENV
                python conda_uploader.py create-channel ${{ inputs.conda_label }} --create-public-channel --channel-description="CondaPackaging Temp Channel"
            fi
        env:
          QUETZ_SERVER: ${{ secrets.QUETZ_SERVER }}
          QUETZ_TOKEN: ${{ secrets.QUETZ_TOKEN }}

      - uses: mamba-org/setup-micromamba@v1 # https://github.com/mamba-org/setup-micromamba
        with:
          environment-name: build-env
          cache-environment: true
          condarc: |
            remote_max_retries: 5
            remote_backoff_factor: 5
            anaconda_upload: false
            conda-build:
              root-dir: ${{ env.CROOT_DIR }}
              output_folder: ${{ env.ARTIFACTS_DIR }}
              anaconda_token: ${{ secrets.CONDA_TOKEN }}
              pkg_format: 2
              zstd_compression_level: 19
            channel_priority: strict
            channels:
              - ${{ env.CONDA_CHANNEL }}
              - conda-forge
          create-args: >-
            python=${{ matrix.pyver }}
            anaconda-client
            boa
            python-dotenv
            typer
            quetz-client
            conda-build=3.25

      - name: Check if debug build
        run: |
          if [[ ${{ inputs.debug_build }} == "True" ]]; then
            echo "PKG_DEBUG=True" >> $GITHUB_ENV
          fi

      - name: try to remove swig on linux
        if: ${{ runner.os == 'Linux' }} # https://docs.github.com/en/actions/learn-github-actions/contexts#runner-context
        continue-on-error: true
        run: |
          sudo apt remove swig make
          sudo rm -r /usr/bin/swig4.0
          sudo rm -rf /usr/share/miniconda

      - name: make dirs
        run: |
          mkdir -p ${{ env.ARTIFACTS_DIR }}
          mkdir -p ${{ env.CROOT_DIR }}

      - name: build local packages
        run: |
          if [[ ${{ inputs.boa }} == true ]]; then
            boa build . --python ${{ matrix.pyver }} --croot ${{ env.CROOT_DIR }} --output-folder ${{ env.ARTIFACTS_DIR }} --pkg-format=2
          else
            conda mambabuild . --python ${{ matrix.pyver }}${{ env.VARIANT_STR }}
          fi
        working-directory: ${{ env.CONDA_DIR }}

      - name: Upload packages to Quetz Server
        if: ${{ inputs.use_quetz }}
        run: |
          python conda_uploader.py upload ${{ env.ARTIFACTS_DIR }} ${{ inputs.conda_label }}
        env:
          QUETZ_SERVER: ${{ secrets.QUETZ_SERVER }}
          QUETZ_TOKEN: ${{ secrets.QUETZ_TOKEN }}

      - name: upload to anaconda
        if: ${{ inputs.boa == false }}
        run: |
          pkg_dir="${{ env.ARTIFACTS_DIR }}/${{ env.PKG_DIR }}"
          noarch_dir="${{ env.ARTIFACTS_DIR }}/noarch"

          # Check if the regular directory exists
          if [ -d "$pkg_dir" ]; then
              # Check if there are any .conda files to upload in the regular directory
              if ls "$pkg_dir"/*.conda 1> /dev/null 2>&1; then
                  path="${pkg_dir}/*.conda"
                  anaconda -t ${{ secrets.CONDA_TOKEN }} upload --force --user ${{ inputs.conda_user }} --label ${{ inputs.conda_label }} $path
              else
                  echo "No .conda files found in $pkg_dir, skipping upload."
              fi
          else
              echo "Regular directory does not exist, skipping upload."
          fi

          # Check if the noarch directory exists
          if [ -d "$noarch_dir" ]; then
              # Check if there are any .conda files to upload in the noarch directory
              if ls "$noarch_dir"/*.conda 1> /dev/null 2>&1; then
                  path="${noarch_dir}/*.conda"
                  anaconda -t ${{ secrets.CONDA_TOKEN }} upload --force --user ${{ inputs.conda_user }} --label ${{ inputs.conda_label }} $path
              else
                  echo "No .conda files found in $noarch_dir, skipping upload."
              fi
          else
              echo "Noarch directory does not exist, skipping upload."
          fi
